class StringBuilder {    var int ptr;    var int cln;    var int cal;};const int _SB_Current = 0;func void SB_Use(var int sb) {    _SB_Current = sb;};func int SB_Get() {	return _SB_Current;};func int SB_New() {    SB_Use(MEM_Alloc(12));    return _SB_Current;};func void SB_InitBuffer(var int size) {    var StringBuilder c; c = _^(_SB_Current);    if(c.ptr) {        MEM_Error("SB_InitBuffer: Der StringBuilder hat bereits einen Buffer.");        return;    };    c.ptr = MEM_Alloc(size);    c.cln = 0;    c.cal = size;};func void SB_Clear() {    var StringBuilder c; c = _^(_SB_Current);    if(c.ptr) {        MEM_Free(c.ptr);    };    c.ptr = 0;    c.cln = 0;    c.cal = 0;};func void SB_Destroy() {    SB_Clear();    MEM_Free(_SB_Current);};func string SB_ToString() {    var StringBuilder c; c = _^(_SB_Current);    if(!c.ptr) { return ""; };    var string ret; ret = "";    var zString z; z = _^(_@s(ret));    z.ptr = MEM_Alloc(c.cln+2)+1;    MEM_CopyBytes(c.ptr, z.ptr, c.cln);    z.len = c.cln;    z.res = c.cln;    return ret;};func void SBraw(var int ptr, var int len) {    var StringBuilder c; c = _^(_SB_Current);    if(!c.ptr) {        SB_InitBuffer(32);    };    var int n; n = c.cln + len;    if(n > c.cal) {        var int o; o = c.cal;        while(n > c.cal);            c.cal *= 2;        end;        c.ptr = MEM_Realloc(c.ptr, o, c.cal);    };    MEM_CopyBytes(ptr, c.ptr + c.cln, len);    c.cln = n;};func void SB(var string s) {    var zString z; z = _^(_@s(s));    SBraw(z.ptr, z.len);};func void SBi(var int i) {    SB(IntToString(i));};func void SBc(var int c) {    SBraw(_@(c), 1);};func void SBflt(var float f) {    SB(FloatToString(f));};func void SBf(var int f) {    f; MEM_Call(SBflt);};